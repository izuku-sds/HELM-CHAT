#!/usr/bin/env bash

# Copyright 2024 The Kubeflow Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This shell script is used to automatically syncing the Kustomize manifests from manifests templated by trainer Helm chart.
# Run 'make sync-manifests' from the root directory of this repository.

echo "Syncing Kustomize manifests from manifests templated by trainer Helm chart..."

set -o errexit
set -o nounset
set -o pipefail
set -x

# Helm chart release name and namespace.
HELM=${HELM:-helm}
TRAINER_CHART_DIR=charts/kubeflow-trainer
RELEASE_NAME=${RELEASE_NAME:-kubeflow-trainer}
RELEASE_NAMESPACE=${RELEASE_NAMESPACE:-kubeflow-system}

# Source directories
SRC_CRD_DIR=manifests/base/crds

# Destination directories
DST_CRD_DIR=${TRAINER_CHART_DIR}/crds
DST_RBAC_DIR=manifests/base/rbac
DST_CONTROLLER_DIR=manifests/base/manager
DST_WEBHOOK_DIR=manifests/base/webhook
DST_RUNTIMES_DIR=manifests/base/runtimes

MANIFESTS_FILE=$(mktemp)
FIND_EXCLUDE_ARGS="-not -name kustomization.yaml -not -name kustomization.yml"
YEAR=$(date +%Y)
LICENSE=$(cat hack/boilerplate/boilerplate.go.txt | sed 's|//|#|' | sed "s|YEAR|${YEAR}|g")
YQ=${YQ:-yq}
YQ_ARGS=".metadata.labels.\"app.kubernetes.io/managed-by\" = \"Kustomize\" | del(.metadata.labels.\"helm.sh/chart\") | ... comments=\"\""

setup() {
    # helm is required to template manifests.
    if ! command -v ${HELM} &>/dev/null; then
        echo "'helm' is not installed, please install it first. Ref: https://helm.sh."
        exit 1
    fi

    # yq is required to parse yaml files.
    if ! command -v ${YQ} &>/dev/null; then
        echo "'yq' is not installed, please install it first. Ref: https://github.com/mikefarah/yq."
        exit 1
    fi

    # Create destination directory if it doesn't exist.
    mkdir -p ${DST_CRD_DIR} ${DST_RBAC_DIR} ${DST_CONTROLLER_DIR} ${DST_WEBHOOK_DIR} ${DST_RUNTIMES_DIR}/pretraining

    ${HELM} dependency build ${TRAINER_CHART_DIR}
    ${HELM} template ${RELEASE_NAME} ${TRAINER_CHART_DIR} --namespace ${RELEASE_NAMESPACE} > "${MANIFESTS_FILE}"
}

update_crds() {
    # Copy all CRD files to destination directory.
    # shellcheck disable=SC2086
    find ${SRC_CRD_DIR} -type f -name "*.yaml" ${FIND_EXCLUDE_ARGS} -exec cp {} ${DST_CRD_DIR} \;
}

update_rbac() {
    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_RBAC_DIR}/service_account.yaml
    ${YQ} -e "select(.kind == \"ServiceAccount\" and .metadata.name == \"kubeflow-trainer-controller-manager\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_RBAC_DIR}/service_account.yaml

    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_RBAC_DIR}/clusterrole.yaml
    ${YQ} -e "select(.kind == \"ClusterRole\" and .metadata.name == \"kubeflow-trainer-controller-manager\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_RBAC_DIR}/clusterrole.yaml

    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_RBAC_DIR}/clusterrole_binding.yaml
    ${YQ} -e "select(.kind == \"ClusterRoleBinding\" and .metadata.name == \"kubeflow-trainer-controller-manager\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_RBAC_DIR}/clusterrole_binding.yaml

    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_RBAC_DIR}/role.yaml
    ${YQ} -e "select(.kind == \"Role\" and .metadata.name == \"kubeflow-trainer-controller-manager\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_RBAC_DIR}/role.yaml

    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_RBAC_DIR}/role_binding.yaml
    ${YQ} -e "select(.kind == \"RoleBinding\" and .metadata.name == \"kubeflow-trainer-controller-manager\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_RBAC_DIR}/role_binding.yaml
}

update_controller_manager() {
    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_CONTROLLER_DIR}/deployment.yaml
    ${YQ} -e "select(.kind == \"Deployment\" and .metadata.name == \"kubeflow-trainer-controller-manager\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_CONTROLLER_DIR}/deployment.yaml

    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_CONTROLLER_DIR}/service.yaml
    ${YQ} -e "select(.kind == \"Service\" and .metadata.name == \"kubeflow-trainer-controller-manager\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_CONTROLLER_DIR}/service.yaml
}

update_webhook() {
    # Do not sync webhook secret from Helm chart as it will be generated by Kustomize.
    # printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_WEBHOOK_DIR}/secret.yaml
    # ${YQ} -e "select(.kind == \"Secret\" and .metadata.name == \"kubeflow-trainer-webhook-cert\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_WEBHOOK_DIR}/secret.yaml

    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_WEBHOOK_DIR}/validating_webhook_configuration.yaml
    ${YQ} -e "select(.kind == \"ValidatingWebhookConfiguration\" and .metadata.name == \"validator.trainer.kubeflow.org\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_WEBHOOK_DIR}/validating_webhook_configuration.yaml
}

update_runtimes() {
    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_RUNTIMES_DIR}/pretraining/torch_distributed.yaml
    ${YQ} -e "select(.kind == \"ClusterTrainingRuntime\" and .metadata.name == \"torch-distributed\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_RUNTIMES_DIR}/pretraining/torch_distributed.yaml

    printf '#\n%s\n#\n\n' "${LICENSE}" > ${DST_RUNTIMES_DIR}/pretraining/mpi_distributed.yaml
    ${YQ} -e "select(.kind == \"ClusterTrainingRuntime\" and .metadata.name == \"mpi-distributed\") | ${YQ_ARGS}" "${MANIFESTS_FILE}" >> ${DST_RUNTIMES_DIR}/pretraining/mpi_distributed.yaml
}

cleanup() {
    rm -f "${MANIFESTS_FILE}"
}

setup
update_crds
# Will not sync RBAC from Helm charts, for now we are using Kubebuilder to generate RBAC files.
# update_rbac
update_controller_manager
update_webhook
# There is something annoying when managing training runtimes in the trainer Helm chart, maybe we should mange runtimes in a separated Helm chart?
# update_runtimes
cleanup
